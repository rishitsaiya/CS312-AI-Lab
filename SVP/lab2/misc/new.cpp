#include <bits/stdc++.h>
#include <chrono>
#include "combo.h"
using namespace std;
using namespace std::chrono; 
#define pii pair<int, int>

pii nil = {-1, -1};



struct Node{
    int path_cost; // accumulated cost
    int color; // visited = 1, else 0 
    int score; // score generated by heuristic
    bool visited; 
    pii parent;

    bool operator <(const Node &n) const{
        return path_cost < n.path_cost; 
    }

    Node(){
        path_cost = 0;
        color = 0;
        score = 0;
        visited = false;
        parent = nil;
    }
};


class JobAllocation{
    vector<vector<int>> cost;
    vector<vector<Node>> G;
    int N, constraint, numStates;

    set<string> open, closed; 

    
    // cost:   Jobs ->
    // Person
    // |
    // âŒ„

    vector<int> start(){
        // Start = {0, 1, 2, 3, ..., N-1}
        vector<int> v;
        for(int i=0; i<N; ++i)
            v.push_back(i);
        return v;
    }


    Node& getNode(pii pos){
        return G[pos.first][pos.second];
    }


    int getCost(pii pos){
        if(pos == nil)
            return 0;
        return cost[pos.first][pos.second];
    }

    
    int getScore(pii pos){
        if(pos == nil)
            return -1;
        return getNode(pos).score;
    }


    int getPathCost(pii pos){
        if(pos == nil)
            return 0;
        return getNode(pos).path_cost;
    }


    vector<pii> getPath(pii pos){
        vector<pii> path;
        for(pii node=pos; node!=nil; node=getNode(node).parent){
            path.push_back(node);
        }
        return path;
    }


    bool goalTest(vector<int> state){
        /* 
         *  Checks if every job is assigned to a unique person
         *   
         * @params:
         *          state(vector<pii>): vector of assignments in form of (personIndex, jobIndex)
         *          constraint(int): maximum bound constraint for path cost
         * @return:
         *          Boolean of whether state is equal to goal or not.
         */
        if(state.empty())
            return false;
        
        set<int> uniqueJob;
        for(int job: state){
            uniqueJob.insert(job);
        }

        return (
            (uniqueJob.size() == N) && 
            (h(state) <= constraint)
        );
    }
    

    vector<vector<int>> movegen(vector<int> node, int density=2){
        int cost = h(node);
        vector<vector<int>> neighbours;

        vector<vector<int>> combos = nCr(node.size(), density);
        for(vector<int> combo: combos){
            vector<int> neighbour = node;
            int d = density-1;
            while(d--){
                for(int i=1; i<combo.size(); ++i){
                    swap(combo[i], combo[i-1]);
                    swap(neighbour[combo[i]], neighbour[combo[i-1]]);
                }
                // cout << "Neighbour: ";
                // for(int i: neighbour)
                //     cout << i << " ";
                // cout << "\n";

                neighbours.push_back(neighbour);

                // cout << "Combo: ";
                // for(int i: combo)
                //     cout << i << " ";
                // cout << "\n";
            }
        }            
        return neighbours;
    }


    int lookAhead(vector<pii> nextMoves, pii pos){
        int i = nextMoves.front().first + 1;
        int sum = 0;

        // printf("nextMoves: \n");
        vector<int> jobsFree;
        for(pii pair: nextMoves){
            // printf("{%d, %d} \n", pair.first, pair.second);
            if(pair != pos)
                jobsFree.push_back(pair.second);
        }
        
        for(; i<N; ++i){
            for(int j: jobsFree){
                sum += cost[i][j];
                // printf("Add %d, %d\n", i, j);
            }
        }
        // printf("Cost: %d, LookAhead: %d\n\n", getCost(pos), sum);
        return sum;
    }


    int h(vector<int> node){
        int sum = 0;
        for(int i=0; i<node.size(); ++i)
            sum += getCost({i, node[i]});        
        return sum;
    }
    

    vector<int> headSortMovegen(vector<int> node, int density){
        int cost = h(node);
        vector<vector<int>> neighbours = movegen(node, density);
        sort(neighbours.begin(), neighbours.end(), [this](const vector<int>& l, const vector<int>& r){
            return h(l) < h(r);
        });

        // Return head with minimum heuristic value
        return neighbours[0];
    }


    string toString(vector<int> node){
        string state = "";
        for(int i: node)
            state += to_string(i) + ",";
        return state;
    }


    vector<int> bestFirstSearch(){
        
        // Init
        vector<int> source = JobAllocation::start();

        priority_queue<vector<int>, vector<vector<int>>, function<bool(vector<int>, vector<int>)>> Q( [this](vector<int> l, vector<int> r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                return (h(l) > h(r));
        });
        

        // Push Source,
        Q.push(source);
        while(!Q.empty()){

            // Get top of queue
            vector<int> node = Q.top();
            Q.pop();

            printf("\nPOP: ");
            printPath(node);

            // Test Goal
            if(goalTest(node)){
                cout << "Goal Found\n";
                return node;
            }

            // Explore successor moves
            for(vector<int> move: movegen(node)){
                if(closed.find(toString(move)) == closed.end()){
                    closed.insert(toString(move));
                    Q.push(move);
                }
            }
        }
        return source;   
    }


    vector<int> hillClimbing(vector<int> node, int density=2){
        
        vector<int> newNode = headSortMovegen(node, density);
        // numStates = 1;
        while(h(newNode) < h(node)){
            node = newNode;
            newNode = headSortMovegen(node, density);
            printPath(node);
            numStates ++;
        }
        return node;
    }


    vector<vector<int>> beam(vector<vector<int>> nodes, int beam_width=2){
        
        if(nodes.empty())
            return nodes;

        // Sort based on heuristic -> h()    
        sort(nodes.begin(), nodes.end(), [this](const vector<int>& l, const vector<int>& r){
            return h(l) < h(r);
        });

        // Make beam, atmost beamWidth elements
        vector<vector<int>> filtered_nodes;
        filtered_nodes.push_back(nodes[0]);

        for(int bw=1; (bw < beam_width) && (bw < nodes.size()); bw++){
            // Only push if heuristic value equal to minimum 
            if(h(nodes[bw]) == h(nodes[0])){
                filtered_nodes.push_back(nodes[bw]);
            }
        }
        return filtered_nodes;
    }


    vector<int> beamSearch(int beam_width = 2){
        
        // Init
        vector<int> source = JobAllocation::start();
        vector<int> node;

        priority_queue<vector<int>, vector<vector<int>>, function<bool(vector<int>, vector<int>)>> Q( [this](vector<int> l, vector<int> r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                return (h(l) > h(r));
        });
        

        // Push Source,
        Q.push(source);
        while(!Q.empty()){

            // Get top of queue
            node = Q.top();
            Q.pop();

            printf("\nPOP: ");
            printPath(node);

            // Test Goal
            if(goalTest(node)){
                cout << "Goal Found\n";
                return node;
            }

            // Explore successor moves
            for(vector<int> move: beam(movegen(node), beam_width)){
                if(closed.find(toString(move)) == closed.end()){
                    closed.insert(toString(move));
                    Q.push(move);
                }
            }
        }
        return node;   
    }



    vector<int> vnd(){

        numStates =1;        
        vector<int> node = JobAllocation::start();
        int density = 2;
        while(density < N){
            // cout << "Density: " << density << "\n";
            node = hillClimbing(node, density);
            density ++;
        }
        return node;
    }


    vector<int> updateMemory(vector<int> M, int tt, vector<int> node, vector<int> prev_node){
        vector<int> change_pos;

        // Find pair of positions swapped
        for(int i = 0; i < N; ++i){
            if(node[i] != prev_node[i]){
                change_pos.push_back(i);
            }
        }

          
        cout << "pos: ";
        for(int i: change_pos)
            cout << i << " ";
        cout << "\n";

        //  Decrement by -1 if not 0, set change_pos indices to tt
        for(int i = 0; i < N; ++i){
            if(i == change_pos[0] || i == change_pos[1]){
                M[i] = tt;
            } else {
                if(M[i] > 0)
                    M[i] -= 1;
            }
        }

        cout << "UpdateM: ";
        for(int i: M)
            cout << i << " ";
        cout << "\n";

        return M;
        
    }


    bool notTabuMove(vector<int> M, vector<int> node, vector<int> prev_node){
        vector<int> change_pos;

        // Find pair of positions swapped
        for(int i = 0; i < N; ++i){
            if(node[i] != prev_node[i]){
                change_pos.push_back(i);
            }
        }
      
        // Is not tabu move
        if(M[change_pos[0]] == 0 && M[change_pos[1]] == 0){
            cout << "NOT TABU: ";
            printPath(prev_node);
            return true;
        }

        return false;
    }


    int count_zeros(vector<int> M){
        int c = 0;
        for(int m: M)
            if(m == 0)
                ++c;
        return c;
    }


    vector<int> tabuSearch(int tt=2){
        /*
         * Implementation of Tabu Search
         *  @Params: tt(int): tabu tenure, default_value = 2
         *  @Return: Solution state found by algorithm 
         * 
        */
        vector<int> node = JobAllocation::start();
        vector<int> M(N); // Memory
        vector<int> F(N); // Frequency
        vector<int> candidate = node;
        vector<int> prev_node = node;
        closed.insert(toString(node));


        while(!goalTest(node)){// Termination Criterion

            printPath(node);

            // Generate neighbourhood
            vector<vector<int>> neighbours = movegen(node);
            if(neighbours.empty())
                break;

            // Sort by heuristic and choose best value node
            sort(neighbours.begin(), neighbours.end(), [this](const vector<int>& l, const vector<int>& r){
                return h(l) < h(r);
            });

            // Find candidate neighbour
            for(vector<int> neighbour: neighbours){
                if(notTabuMove(M, node, neighbour) && neighbour != node){
                    if(closed.find(toString(candidate)) == closed.end()){
                        closed.insert(toString(candidate));
                        candidate = neighbour;
                        break;
                    }
                }
            }
            
            // Aspiration Criteria
            if(h(node) < h(candidate)){
                // Choose tabu move instead
                for(vector<int> neighbour: neighbours){
                    if(!notTabuMove(M, node, neighbour) && neighbour != node){
                        if(closed.find(toString(candidate)) == closed.end()){
                            closed.insert(toString(candidate));
                            candidate = neighbour;
                            break;
                        }
                    }
                }
            }
            node = candidate;
            if(node == JobAllocation::start() || count_zeros(M) < 2)
                return node;


            if(node == prev_node)
                break;

            // Update M
            M = updateMemory(M, tt, node, prev_node);
            
            // Update prev_node
            prev_node = node;
        }
        return node;
    }


public:
    void input(){
        int cell_cost;
        
        // Input dimension N and constraint
        cin >> N >> constraint;
        
        // Input N x N cost matrix
        for(int i=0; i<N; ++i){
            vector<int> rowC;
            vector<Node> rowG;
            
            for(int j=0; j<N; ++j){
                cin >> cell_cost;
                rowC.push_back(cell_cost);
                rowG.push_back(Node());
            }
            JobAllocation::cost.push_back(rowC);
            JobAllocation::G.push_back(rowG);
        }
    }


    void printPath(vector<int> state, bool verbose=false){
        for(int i=0; i<state.size(); ++i){
            if(verbose)
                printf("{%d, %d}: %d, ", i, state[i], getCost({i, state[i]}));
            else
                printf("%d, ", state[i]);
        }
        printf(" Score: %d\n", h(state));
    }

    void testPrint(){
        // Get starting timepoint 
        auto start = high_resolution_clock::now(); 
    
        // vector<int> sol = bestFirstSearch(); numStates = closed.size();
        // vector<int> sol = hillClimbing(JobAllocation::start(), 2); 
        // vector<int> sol = beamSearch(4); numStates = closed.size();
        vector<int> sol = vnd(); numStates --;
        // vector<int> sol = tabuSearch(3); 
        
        // Get ending timepoint 
        auto stop = high_resolution_clock::now(); 
    
        // Get duration. Substart timepoints to  
        // get durarion. To cast it to proper unit 
        // use duration cast method 
        auto duration = duration_cast<microseconds>(stop - start); 
        cout << "Num states: " << numStates << " states" << endl; 
        cout << "Time taken: " << duration.count() << " microseconds" << endl; 
        
        
        printPath(sol);
        cout << "BFS Total cost = " << h(sol) << "\n";
    }
};


int main(){
    JobAllocation solver;
    solver.input();
    solver.testPrint();
    return 0;
}