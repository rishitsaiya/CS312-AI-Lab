#include <bits/stdc++.h>
using namespace std;
#define pii pair<int, int>

pii nil = {-1, -1};



struct Node{
    int path_cost; // accumulated cost
    int color; // visited = 1, else 0 
    int score; // score generated by heuristic
    bool visited; 
    pii parent;

    bool operator <(const Node &n) const{
        return path_cost < n.path_cost; 
    }

    Node(){
        path_cost = 0;
        color = 0;
        score = 0;
        visited = false;
        parent = nil;
    }
};


class JobAllocation{
    vector<vector<int>> cost;
    vector<vector<Node>> G;
    int N;

    set<string> open, closed; 

    // cost:   Jobs ->
    // Person
    // |
    // âŒ„

    Node& getNode(pii pos){
        return G[pos.first][pos.second];
    }


    int getCost(pii pos){
        if(pos == nil)
            return 0;
        return cost[pos.first][pos.second];
    }

    
    int getScore(pii pos){
        if(pos == nil)
            return -1;
        return getNode(pos).score;
    }


    int getPathCost(pii pos){
        if(pos == nil)
            return 0;
        return getNode(pos).path_cost;
    }


    vector<pii> getPath(pii pos){
        vector<pii> path;
        for(pii node=pos; node!=nil; node=getNode(node).parent){
            path.push_back(node);
        }
        return path;
    }


    bool goalTest(vector<pii> state, int constraint=INT_MAX){
        /* 
         *  Checks if every job is assigned to a unique person
         *   
         * @params:
         *          state(vector<pii>): vector of assignments in form of (personIndex, jobIndex)
         *          constraint(int): maximum bound constraint for path cost
         * @return:
         *          Boolean of whether state is equal to goal or not.
         */
        if(state.empty())
            return false;
        
        set<int> uniquePerson, uniqueJob;
        for(pii pair: state){
            if(pair.first == -1 || pair.second == -1) 
                return false;
            uniquePerson.insert(pair.first);
            uniqueJob.insert(pair.second);
            printf("{%d, %d}, ", pair.first, pair.second);
        }

        // cout << (uniqueJob.size() == N);
        // cout << (uniquePerson.size() == N);
                
        cout << (getPathCost(state.front())) << "<=" << constraint << "\n\n";

        return (
            (uniqueJob.size() == N) && 
            (uniquePerson.size() == N) && 
            (getNode(state.front()).path_cost <= constraint)
        );
    }

    

    vector<pii> moveGen(pii pos){
        /*
         * Generates a set of next possible moves depending on input position.
         * 
         * @params: 
         *          pos(pair<int, int>): position of current state
         * @return: 
         *          vector<pair<int, int>>: vector of next possible positions
         */
        //
        vector<pii> nextMoves;
        if(pos.first >= N-1){
            nextMoves.clear();
            return nextMoves;
        }
        
        // Mark jobs already taken
        set<int> jobsTaken;
        for(pii node: getPath(pos)){
            jobsTaken.insert(node.second);
        }

        // Search in remaining jobs
        for(int i=0; i<N; ++i){
            if(jobsTaken.find(i) == jobsTaken.end()) //if job not taken
                nextMoves.push_back(make_pair(pos.first+1, i));
        }
        return nextMoves;
    }


    int lookAhead(vector<pii> nextMoves, pii pos){
        int i = nextMoves.front().first + 1;
        int sum = 0;

        // printf("nextMoves: \n");
        vector<int> jobsFree;
        for(pii pair: nextMoves){
            // printf("{%d, %d} \n", pair.first, pair.second);
            if(pair != pos)
                jobsFree.push_back(pair.second);
        }
        
        for(; i<N; ++i){
            for(int j: jobsFree){
                sum += cost[i][j];
                // printf("Add %d, %d\n", i, j);
            }
        }
        // printf("Cost: %d, LookAhead: %d\n\n", getCost(pos), sum);
        return sum;
    }


    vector<pii> heuristic(vector<pii> nextMoves, string h_type="greedy"){
        printf("nextMoves: ");
        for(pii p: nextMoves){
            printf("{%d, %d}, ", p.first, p.second);
        }
        cout << "\n";


        // Greedy Heuristic: chooses minimum from nextMoves //
        if(h_type == "greedy"){ 
            
            sort(nextMoves.begin(), nextMoves.end(), [this](pii l, pii r){ // Lambda Comparator
                // Sort in ascending order of costs
                if(l == nil) return true;
                if(r == nil) return false;
                return (getCost(l) < getCost(r));
            });

            int rank = 0; // lower => more optimal for minimum 
            for(pii move: nextMoves){ // iterate nextMoves sorted in ascending order
                if(!getNode(move).visited){
                    getNode(move).score = getCost(move);
                    // rank++;
                }
            }
            return nextMoves;
        }
        // ------------------------------------------------
        else if(h_type == "lookahead"){
            // sort(nextMoves.begin(), nextMoves.end(), [this, nextMoves](pii l, pii r){ // Lambda Comparator
            //     // Sort in ascending order of costs
            //     if(l == nil) return true;
            //     if(r == nil) return false;
            //     return ((getNode(l).path_cost + lookAhead(nextMoves, l)) < (getNode(r).path_cost + lookAhead(nextMoves, r)));
            // });

            for(pii move: nextMoves){
                getNode(move).score = getNode(move).path_cost + getCost(move) + lookAhead(nextMoves, move);
                // printf("Move: %d, %d   Score: %d\n", move.first, move.second, getNode(move).score);
            }

            sort(nextMoves.begin(), nextMoves.end(), [this, nextMoves](pii l, pii r){ // Lambda Comparator
                // Sort in ascending order of costs
                if(l == nil) return true;
                if(r == nil) return false;
                return ((getNode(l).score) < (getNode(r).score));
            });


            int rank = 0; // lower => more optimal for minimum 
            for(pii move: nextMoves){ // iterate nextMoves sorted in ascending order
                if(!getNode(move).visited){
                    getNode(move).score = rank;
                    rank++;
                }
            }
            return nextMoves;
        }
    }
    
    void printQueue(priority_queue<pii, vector<pii>, function<bool(pii,pii)>> Q){
        cout << "Q ";
        while(!Q.empty()){
            pii node = Q.top();
            printf("{%d, %d} = %d, ", node.first, node.second, getScore(node));
            Q.pop();
        }
        cout << "\n";
    }
    
    pii bestFirstSearch(int constraint=INT_MAX){
        
        priority_queue<pii, vector<pii>, function<bool(pii,pii)>> Q( [this](pii l, pii r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                if(l == nil) return true;
                if(r == nil) return false;
                return (getNode(l).score > getNode(r).score);
        });
        
        printQueue(Q);

        // Push Source,
        Q.push(nil);
        while(!Q.empty()){

            // Get top of queue
            pii source = Q.top();
            Q.pop();
            printf("Popped: {%d, %d}\n", source.first, source.second);
            printQueue(Q);

            // Mark visited
            if(source != nil){
                getNode(source).visited = true;
                printf("x: %d, y: %d, Score = %d\n", source.first, source.second, getNode(source).path_cost);
            }
            
            // Test Goal
            if(goalTest(getPath(source), constraint)){
                cout << "Goal Found\n";
                return source;
            }

            // Explore successor moves
            for(pii move: heuristic(moveGen(source), "greedy")){
                if(!getNode(move).visited){
                    getNode(move).parent = source;
                    getNode(move).path_cost = getPathCost(source) + getCost(move);
                    Q.push(move);
                }
            }
        }
        return nil;
    }


    // pii hillClimbing(){
    //     priority_queue<pii, vector<pii>, function<bool(pii,pii)>> Q( [this](pii l, pii r) -> bool {// Lambda Comparator Constructor for function<>
    //             // Min Priority Queue based on score
    //             if(l == nil) return true;
    //             if(r == nil) return false;
    //             return (getNode(l).score > getNode(r).score);
    //     });
    //     // Push Source,
    //     Q.push(nil);
    //     while(!Q.empty()){

    //         // Get top of queue
    //         pii source = Q.top();
    //         Q.pop();

    //         // Mark visited
    //         if(source != nil){
                
    //             printf("x: %d, y: %d, Score = %d\n", source.first, source.second, getNode(source).path_cost);
    //         }
            
    //         // Test Goal
    //         if(goalTest(getPath(source)))
    //             return source;

    //         // Explore successor moves
    //         for(pii move: heuristic(moveGen(source), "lookahead")){
    //             if(!getNode(move).visited){
    //                 getNode(move).visited = true;
    //                 getNode(move).parent = source;
    //                 getNode(move).path_cost = getPathCost(source) + getCost(move);
    //                 Q.push(move);   
    //             }
    //             break;
    //         }
    //     }
    //     return nil;
    // }

int h(vector<int> node){
    int sum = 0;
    for(int i=0; i<node.size(); ++i)
        sum += getCost({i, node[i]});        
    return sum;
}


vector<int> headSortMovegen(vector<int> node){
    int cost = h(node);
    pii exchangePos = nil;

    // For all pairs
    for(int i=0; i<N-1; ++i){
        for(int j=i+1; j<N; ++j){
            int newCost = cost - getCost({i, node[i]}) - getCost({j, node[j]}) + getCost({i, node[j]}) + getCost({j, node[i]});
            if(newCost < cost){
                cost = newCost;
                exchangePos = {i, j};
            }
        }
    }

    if(exchangePos != nil)
        swap(node[exchangePos.first], node[exchangePos.second]);
        
    return node;
}


vector<int> hillClimbing(){
        
        vector<int> node;
        
        // Init
        for(int i=0; i<N; ++i)
            node.push_back(i);
        
        vector<int> newNode = headSortMovegen(node);

        while(h(newNode) < h(node)){
            node = newNode;
            
            for(int i: node)
                cout << i << " ";
            cout << "\n";

            newNode = headSortMovegen(node);
        }
        return newNode;
    }


    vector<pii> beam(vector<pii> nextMoves, int beam_width){
        if(beam_width >= nextMoves.size())
            return nextMoves;
            
        cout << "Beam: ";
        for(pii pair: vector<pii>(&nextMoves[0], &nextMoves[beam_width])){
            printf("{%d, %d}, ", pair.first, pair.second);
        } cout << "\n";
        return vector<pii>(&nextMoves[0], &nextMoves[beam_width]);
    }


    pii beamSearch(int beam_width, int constraint=INT_MAX){
        
        priority_queue<pii, vector<pii>, function<bool(pii,pii)>> Q( [this](pii l, pii r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                if(l == nil) return true;
                if(r == nil) return false;
                return (getNode(l).score > getNode(r).score);
        });
        
        printQueue(Q);

        // Push Source,
        Q.push(nil);
        while(!Q.empty()){

            // Get top of queue
            pii source = Q.top();
            Q.pop();
            printf("Popped: {%d, %d}\n", source.first, source.second);
            printQueue(Q);

            // Mark visited
            if(source != nil){
                // getNode(source).visited = true;
                printf("x: %d, y: %d, Score = %d\n", source.first, source.second, getNode(source).path_cost);
            }
            
            // Test Goal
            if(goalTest(getPath(source), constraint)){
                cout << "Goal Found\n";
                return source;
            }

            // Explore successor moves
            for(pii move: beam(heuristic(moveGen(source), "greedy"), beam_width)){
                // if(!getNode(move).visited){
                    getNode(move).parent = source;
                    getNode(move).path_cost = getPathCost(source) + getCost(move);
                    Q.push(move);
                // }
            }
        }
        return nil;
    }


    pii vnd(int constraint=INT_MAX){
        priority_queue<pii, vector<pii>, function<bool(pii,pii)>> Q( [this](pii l, pii r) -> bool {// Lambda Comparator Constructor for function<>
                // Min Priority Queue based on score
                if(l == nil) return true;
                if(r == nil) return false;
                return (getNode(l).score > getNode(r).score);
        });
        // Push Source,
        Q.push(nil);
        while(!Q.empty()){

            // Get top of queue
            pii source = Q.top();
            Q.pop();

            // Mark visited
            if(source != nil){
                
                printf("x: %d, y: %d, Score = %d\n", source.first, source.second, getNode(source).path_cost);
            }
            
            // Test Goal
            if(goalTest(getPath(source)))
                return source;

            // Explore successor moves
            for(pii move: heuristic(moveGen(source), "lookahead")){
                if(!getNode(move).visited){
                    getNode(move).visited = true;
                    getNode(move).parent = source;
                    getNode(move).path_cost = getPathCost(source) + getCost(move);
                    Q.push(move);
                }
                break;
            }
        }
        return nil;
    }




public:
    void input(){
        int cell_cost;
        
        // Input dimension N
        cin >> N;
        
        // Input N x N cost matrix
        for(int i=0; i<N; ++i){
            vector<int> rowC;
            vector<Node> rowG;
            
            for(int j=0; j<N; ++j){
                cin >> cell_cost;
                rowC.push_back(cell_cost);
                rowG.push_back(Node());
            }
            JobAllocation::cost.push_back(rowC);
            JobAllocation::G.push_back(rowG);
        }
    }  


    void testPrint(){
        // pii sol = bestFirstSearch(); 
        // pii sol = beamSearch(N, 13);
        // printf("Total Cost: %d\n", getNode(sol).path_cost);
        vector<int> sol = hillClimbing(); 
        for(int i=0; i<sol.size(); ++i){
            ;
            printf("{%d, %d}: %d, ", i, sol[i], getCost({i, sol[i]}));
        }
        cout << "\n";
        cout << "Total cost = " << h(sol) << "\n";
    }
};


int main(){
    JobAllocation solver;
    solver.input();
    solver.testPrint();
    return 0;
}